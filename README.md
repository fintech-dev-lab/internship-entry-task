# Описание api

Api проекта состоит из 3х endpoint'ов:

#### Создание игры
`GET api/v1/games/new` — создает новую игру, возвращает экземпляр созданной игры:
```
{
  "game": {
  
    "game_id": "3fa85f64-5717-4562-b3fc-2c963f66afa6", // id игры
    "field": [
      [
        ["_", "_", "_"],
        ["_", "_", "_"],
        ["_", "_", "_"]
      ]
    ], // игровое поле, клетка может принимать значкения: _ если пустая, X и O если занята соответсвующим игроком
    "current_player": 0, // игрок текущего хода (0 если X, 1 если O)
    "winner": null // победитель, null если игра продолжается иначе игра завершена: 0 — победил игрок X, 1 — победил игрок O, 2 — ничья
  }
}
```

#### Новый ход в игре
`POST /api/v1/games/{id}/move` — делает ход за текущего игрока в игре.
Принимает координаты следующего хода в виде:
```
{
  "position": {
    "x": 0, // за начало координат принят левый верхний угол поля
    "y": 0
  }
}
```
Возвращает экземпляр обновленной игры.

#### Получение состояние игры по id
`GET /api/v1/games/{id}` — получает игру по id, возвращает экземпляр игры.

# Принятые решения
Проект создавался с оглядкой на DDD, с выносом всей логики в проект `Domain`.

В качестве посредника между репозиторием и слоем приложения был выбран `GameProvider`, отвечающий за кеширование и определение источника данных.

Для постоянного хранения данных используется PostgresQL с адаптером в виде `PostgresRepository`, в качестве ORM был выбран `Dapper`, для миграций `FluentMigrator`.

Для обработки `ETag` создан специальный middleware (хотя я бы предпочел использовать `idempotence_key` присылаемый клиентом).



# Задача #1 на стажировку backend разработчик Банка C#/PostgreSQL

Спроектируйте и реализуйте REST API для игры в крестики нолики

Должен поддерживаться формат сообщений json. 

## Описание

Для разработки сайта и мобильного приложения для игры в крестики нолики NxN (N >= 3) для двух игроков требуется реализовать web api. Игра проходит по обычным правилам, за исключением одного - каждый третий ход игры существует вероятность 10%, что поставится значок противника.

- создание новой игры,
- ходы двух игроков,
- фиксация победы или ничьей.
- размер поля и условия победы задаются через переменные окружения

Платформа

- **Платформа:** .NET 9
- **Хранилище:** любая СУБД (можно файловую).

## Формат решения

### Обязательно:

- Вы делаете форк от этого репозитория и предоставляете ссылку PR с вашим решением
- проект должен быть выложен на GitHub и открываться с помощьюм VS2022
- в readme.md репозитория или на выделенной онлайн странице должно быть описание API и принятых архитектурных решений
- проект собирается в докер и разворачиватся в рабочее состояние docker-compose up

## Автоматическая проверка

### Запуск

- В репозитории есть **`Dockerfile`** (обязательно) и при необходимости **`docker-compose.yml`**.
- Приложение внутри контейнера слушает **порт 8080**.
- На запрос `GET /health` отвечает `200 OK`.

### Тесты

- Есть интеграционные и unit тесты
- Минимальное покрытие кода — **30 %**.
- Запуск тестов в CI и локально — `dotnet test` (или аналогичная команда).

### Дополнительные тонкости (обязательно)

- **Concurrency & идемпотентность**  
   При гонке двух `POST /moves` с одинаковым телом второй запрос обязан вернуть 200 OK и тот же `ETag`.

- **Persistence crash-safe**  
   После перезапуска контейнера мы выполняем `GET /games/{id}` и делаем следующий ход. Сессия игрока сохраняется.

- **Негативные тесты**  
   Любой некорректный JSON (пример ниже) → HTTP 400 (RFC 7807)

## Цель задания

Предоставить кандидату возможность продемонстрировать свои знания
